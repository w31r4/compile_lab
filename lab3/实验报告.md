# 编译原理实验报告 - 语法分析算法实现

**实验名称**: 语法分析算法实现（任务3.1、3.2、3.3）  
**学生姓名**: [请填写]  
**学号**: [请填写]  
**完成日期**: 2025年11月20日

---

## 目录

1. [实验概述](#实验概述)
2. [项目结构](#项目结构)
3. [核心数据结构设计](#核心数据结构设计)
4. [算法实现](#算法实现)
   - [任务3.1: 消除左递归](#任务31-消除左递归)
   - [任务3.2: 提取左公因子](#任务32-提取左公因子)
   - [任务3.3: 计算FIRST集和FOLLOW集](#任务33-计算first集和follow集)
5. [测试结果](#测试结果)
6. [使用说明](#使用说明)
7. [总结与心得](#总结与心得)

---

## 实验概述

本实验实现了编译原理中语法分析阶段的三个核心算法：

1. **任务3.1**: 消除上下文无关文法中的左递归（包括直接和间接左递归）
2. **任务3.2**: 提取文法中的左公因子，消除回溯
3. **任务3.3**: 计算文法的FIRST集和FOLLOW集

所有算法均使用Python实现，提供了清晰的命令行可视化输出，便于观察算法的执行过程和结果。

---

## 项目结构

```
lab3/
├── src/                          # 源代码目录
│   ├── grammar.py                # 核心数据结构定义
│   ├── parser.py                 # 文法文件解析器
│   ├── left_recursion.py         # 消除左递归算法
│   ├── left_factoring.py         # 提取左公因子算法
│   └── first_follow.py           # FIRST集和FOLLOW集计算
├── test_grammars/                # 测试文法文件
│   └── expr_grammar.txt          # 表达式文法（带左递归）
├── main.py                       # 主程序入口
├── pyproject.toml                # 项目配置文件（uv）
└── 实验报告.md                   # 本实验报告
```

---

## 核心数据结构设计

### 1. Symbol类（文法符号）

```python
@dataclass
class Symbol:
    value: str                    # 符号值（如 'E', '+', 'id'）
    symbol_type: SymbolType       # 符号类型（终结符/非终结符/空串）
```

**设计思路**:
- 使用枚举类型`SymbolType`区分符号类型
- 重载`__str__`、`__hash__`和`__eq__`方法，便于打印和集合操作
- 预定义空串符号`EPSILON = Symbol("@", SymbolType.EPSILON)`

### 2. Production类（产生式）

```python
@dataclass
class Production:
    left: Symbol                  # 产生式左部（非终结符）
    right: List[Symbol]           # 产生式右部（符号列表）
```

**设计思路**:
- 使用`@dataclass`简化类的定义
- 提供友好的字符串表示，便于可视化输出

### 3. Grammar类（文法）

```python
@dataclass
class Grammar:
    non_terminals: Set[Symbol]    # 非终结符集合
    terminals: Set[Symbol]        # 终结符集合
    productions: List[Production] # 产生式列表
    start_symbol: Symbol          # 开始符号
    symbol_map: Dict[str, Symbol] # 符号映射（值 -> Symbol对象）
```

**设计思路**:
- 使用`symbol_map`统一管理所有符号，避免重复创建
- 提供`add_symbol()`和`add_production()`方法，方便构建文法
- 提供`get_productions_for()`方法，快速获取非终结符的所有产生式

---

## 算法实现

### 任务3.1: 消除左递归

**算法步骤**:

1. **对非终结符排序**: 按字典序排序
2. **消除间接左递归**: 对于每个非终结符Ai，检查其产生式是否以排在前面的非终结符Aj开头，如果是则进行代换
3. **消除直接左递归**: 对于存在左递归的产生式Ai -> Aiα | β，转换为：
   - Ai -> βAi'
   - Ai' -> αAi' | ε

**关键代码**（`src/left_recursion.py`）:

```python
def _eliminate_indirect_left_recursion(self, sorted_non_terminals: List[Symbol]) -> None:
    """消除间接左递归"""
    for i, ai in enumerate(sorted_non_terminals):
        ai_productions = self.result_grammar.get_productions_for(ai)
        
        for prod in ai_productions:
            if not prod.right or prod.right[0] == EPSILON:
                continue
            
            first_symbol = prod.right[0]
            if first_symbol.symbol_type != SymbolType.NON_TERMINAL:
                continue
            
            # 查找first_symbol在排序列表中的位置
            try:
                j = sorted_non_terminals.index(first_symbol)
            except ValueError:
                continue
            
            # 如果first_symbol排在ai前面，进行代换
            if j < i:
                # 用Aj的产生式代换
                aj_productions = self.result_grammar.get_productions_for(first_symbol)
                for aj_prod in aj_productions:
                    new_right = aj_prod.right + prod.right[1:]
                    self.result_grammar.add_production(ai, new_right)

def _eliminate_direct_left_recursion(self, sorted_non_terminals: List[Symbol]) -> None:
    """消除直接左递归"""
    for ai in sorted_non_terminals:
        ai_productions = self.result_grammar.get_productions_for(ai)
        
        # 分离左递归和非左递归产生式
        left_recursive_prods = [p for p in ai_productions if p.right and p.right[0] == ai]
        non_left_recursive_prods = [p for p in ai_productions if not (p.right and p.right[0] == ai)]
        
        if left_recursive_prods:
            # 创建新非终结符Ai'
            new_nt = self.result_grammar.add_symbol(f"{ai.value}'", SymbolType.NON_TERMINAL)
            
            # 移除Ai的所有产生式
            for prod in ai_productions:
                self.result_grammar.productions.remove(prod)
            
            # 添加Ai -> βAi'
            for prod in non_left_recursive_prods:
                new_right = prod.right + [new_nt]
                self.result_grammar.add_production(ai, new_right)
            
            # 添加Ai' -> αAi'
            for prod in left_recursive_prods:
                alpha = prod.right[1:]
                new_right = alpha + [new_nt]
                self.result_grammar.add_production(new_nt, new_right)
            
            # 添加Ai' -> ε
            self.result_grammar.add_production(new_nt, [EPSILON])
```

**测试示例**:

输入文法（带左递归）:
```
E -> T E'
E' -> + T E' | ε
T -> F T'
T' -> * F T' | ε
F -> ( E ) | id
```

消除左递归后（处理间接左递归）:
```
T -> ( E ) T' | id T'  # 原T -> F T'，F被展开
```

---

### 任务3.2: 提取左公因子

**算法步骤**:

1. **构建Trie树**: 对每个非终结符的所有产生式右部构建前缀树
2. **查找最长公共前缀**: 在Trie树中查找最长公共前缀
3. **提取左公因子**: 如果存在公共前缀，创建新的非终结符，并重构产生式

**关键代码**（`src/left_factoring.py`）:

```python
class TrieNode:
    def insert(self, symbols: List[Symbol], production: Production) -> None:
        """将符号序列插入Trie树"""
        if not symbols:
            self.is_end = True
            self.productions.append(production)
            return
        
        first_symbol = symbols[0]
        if first_symbol.value not in self.children:
            self.children[first_symbol.value] = TrieNode()
        
        self.children[first_symbol.value].insert(symbols[1:], production)
    
    def get_longest_common_prefix(self) -> Tuple[List[Symbol], List[TrieNode]]:
        """获取最长公共前缀"""
        prefix_symbols = []
        current = self
        
        while len(current.children) == 1 and not current.is_end:
            symbol_value, child_node = next(iter(current.children.items()))
            prefix_symbols.append(Symbol(symbol_value, SymbolType.TERMINAL))
            current = child_node
        
        child_nodes = list(current.children.values())
        return prefix_symbols, child_nodes

def _process_non_terminal(self, non_terminal: Symbol) -> None:
    """处理单个非终结符，提取其产生式的左公因子"""
    productions = self.result_grammar.get_productions_for(non_terminal)
    
    if len(productions) < 2:
        return
    
    # 构建Trie树
    trie_root = TrieNode()
    for prod in productions:
        trie_root.insert(prod.right, prod)
    
    # 查找最长公共前缀
    prefix_symbols, child_nodes = trie_root.get_longest_common_prefix()
    
    if prefix_symbols and len(child_nodes) >= 2:
        # 提取左公因子
        new_nt = self.result_grammar.add_symbol(f"{non_terminal.value}''", SymbolType.NON_TERMINAL)
        
        # 移除旧产生式，添加新产生式
        # A -> prefix B
        # B -> suffix1 | suffix2 | ...
```

**测试示例**:

输入文法:
```
S -> apple | apply | application | ball | bat | bath
```

提取左公因子后:
```
S -> appl S' | ba S''
S' -> e | y | ication
S'' -> ll | t | th
```

---

### 任务3.3: 计算FIRST集和FOLLOW集

#### FIRST集计算

**算法步骤**:

1. **初始化**:
   - 对每个终结符a，FIRST(a) = {a}
   - 对ε，FIRST(ε) = {ε}
   - 对每个非终结符，FIRST = ∅

2. **迭代计算**:
   - 对于产生式 A -> X1 X2 ... Xk:
     - 将FIRST(X1)中的所有非ε元素加入FIRST(A)
     - 如果ε ∈ FIRST(X1)，则将FIRST(X2)中的所有非ε元素加入FIRST(A)
     - 如果所有Xi的FIRST集都包含ε，则将ε加入FIRST(A)

**关键代码**（`src/first_follow.py`）:

```python
def _add_first_from_production(self, production) -> None:
    """从产生式添加FIRST集元素"""
    left_nt = production.left
    right_symbols = production.right
    
    if not right_symbols or right_symbols == [EPSILON]:
        self.first_sets[left_nt].add(EPSILON)
        return
    
    for i, symbol in enumerate(right_symbols):
        if symbol in self.first_sets:
            symbol_first = self.first_sets[symbol]
            self.first_sets[left_nt].update(symbol_first - {EPSILON})
        
        if symbol not in self.first_sets or EPSILON not in self.first_sets[symbol]:
            break
        
        if i == len(right_symbols) - 1:
            self.first_sets[left_nt].add(EPSILON)
```

#### FOLLOW集计算

**算法步骤**:

1. **初始化**:
   - FOLLOW(开始符号) = {$}
   - 其他非终结符的FOLLOW集 = ∅

2. **迭代应用规则**:
   - 对于产生式 A -> αBβ:
     - 将FIRST(β)中的所有非ε元素加入FOLLOW(B)
     - 如果ε ∈ FIRST(β)，则将FOLLOW(A)加入FOLLOW(B)
   - 对于产生式 A -> αB:
     - 将FOLLOW(A)加入FOLLOW(B)

**关键代码**（`src/first_follow.py`）:

```python
def _iterate_follow_sets(self) -> None:
    """迭代计算FOLLOW集"""
    changed = True
    while changed:
        changed = False
        
        for production in self.grammar.productions:
            right_symbols = production.right
            
            for i, symbol in enumerate(right_symbols):
                if symbol.symbol_type != SymbolType.NON_TERMINAL:
                    continue
                
                old_size = len(self.follow_sets[symbol])
                
                # 规则1: A -> αBβ
                if i + 1 < len(right_symbols):
                    beta = right_symbols[i + 1:]
                    first_of_beta = self._compute_first_of_string(beta)
                    self.follow_sets[symbol].update(first_of_beta - {EPSILON})
                    
                    # 规则2: 如果ε ∈ FIRST(β)
                    if EPSILON in first_of_beta:
                        self.follow_sets[symbol].update(self.follow_sets[production.left])
                else:
                    # 规则3: A -> αB
                    self.follow_sets[symbol].update(self.follow_sets[production.left])
                
                if len(self.follow_sets[symbol]) > old_size:
                    changed = True
```

---

## 测试结果

### 测试环境

- **Python版本**: 3.14.0
- **包管理器**: uv
- **运行命令**: `uv run main.py test_grammars/expr_grammar.txt -a -v`

### 测试文法

**输入文法**（`test_grammars/expr_grammar.txt`）:
```
# 表达式文法（带左递归）
# 非终结符
E, E', T, T', F
# 终结符
+, *, (, ), id
# 开始符号
E
# 产生式
E -> T E'
E' -> + T E' | @
T -> F T'
T' -> * F T' | @
F -> ( E ) | id
```

### 测试结果

#### 1. 消除左递归

**处理过程**:
- 非终结符排序: `['E', "E'", 'F', 'T', "T'"]`
- 发现间接左递归: `T -> F T'`
- 用F的产生式代换，得到:
  - `T -> ( E ) T'`
  - `T -> id T'`

**结果文法**:
```
E -> T E'
E' -> + T E' | ε
T -> ( E ) T' | id T'
T' -> * F T' | ε
F -> ( E ) | id
```

#### 2. 提取左公因子

**处理结果**: 该文法不存在可提取的左公因子，文法保持不变。

#### 3. 计算FIRST集

**计算结果**:
```
FIRST(E)   = {(, id}
FIRST(E')  = {+, ε}
FIRST(T)   = {(, id}
FIRST(T')  = {*, ε}
FIRST(F)   = {(, id}
```

**计算过程**: 经过2次迭代后收敛。

#### 4. 计算FOLLOW集

**计算结果**:
```
FOLLOW(E)   = {$, )}
FOLLOW(E')  = {$, )}
FOLLOW(T)   = {$, ), +}
FOLLOW(T')  = {$, ), +}
FOLLOW(F)   = {$, ), *, +}
```

**计算过程**: 经过4次迭代后收敛。

---

## 使用说明

### 环境准备

1. **安装uv**（Python包管理器）:
   ```bash
   curl -LsSf https://astral.sh/uv/install.sh | sh
   ```

2. **项目初始化**（已完成）:
   ```bash
   uv init
   ```

### 运行程序

#### 基本用法

```bash
uv run main.py <grammar_file> [options]
```

#### 参数说明

- `grammar_file`: 文法文件路径（.txt格式）
- `--eliminate-left-recursion, -e`: 消除左递归（任务3.1）
- `--extract-left-factoring, -f`: 提取左公因子（任务3.2）
- `--compute-first, -first`: 计算FIRST集（任务3.3）
- `--compute-follow, -follow`: 计算FOLLOW集（任务3.3）
- `--all, -a`: 执行所有操作
- `--verbose, -v`: 显示详细处理过程
- `--output <file>, -o <file>`: 将结果输出到文件

#### 示例

1. **消除左递归**:
   ```bash
   uv run main.py test_grammars/expr_grammar.txt -e -v
   ```

2. **提取左公因子**:
   ```bash
   uv run main.py test_grammars/expr_grammar.txt -f -v
   ```

3. **计算FIRST集和FOLLOW集**:
   ```bash
   uv run main.py test_grammars/expr_grammar.txt -first -follow -v
   ```

4. **执行所有操作**:
   ```bash
   uv run main.py test_grammars/expr_grammar.txt -a -v
   ```

5. **将结果保存到文件**:
   ```bash
   uv run main.py test_grammars/expr_grammar.txt -a -v -o result.txt
   ```

### 文法文件格式

文法文件使用以下格式：

```text
# 注释行（以#开头）
# 非终结符（大写字母，用逗号分隔）
E, T, F
# 终结符（小写字母或符号，用逗号分隔）
+, *, (, ), id
# 开始符号
E
# 产生式（支持|分隔多个候选式，@表示空串ε）
E -> T + E | T
T -> F * T | F
F -> ( E ) | id
```

---

## 总结与心得

### 实验收获

1. **深入理解语法分析理论**: 通过实现消除左递归、提取左公因子、计算FIRST/FOLLOW集等算法，深入理解了自顶向下语法分析的理论基础。

2. **掌握数据结构的设计**: 设计了Symbol、Production、Grammar等核心数据结构，为算法实现提供了统一的数据接口。

3. **提高算法实现能力**: 实现了复杂的编译原理算法，包括间接左递归的消除、Trie树的应用、迭代计算FIRST/FOLLOW集等。

4. **增强代码可视化能力**: 通过详细的日志输出，实现了算法的可视化展示，便于调试和理解算法执行过程。

### 技术亮点

1. **模块化设计**: 将不同算法封装在独立的模块中，提高了代码的可维护性和可扩展性。

2. **使用Trie树**: 在提取左公因子算法中，使用Trie树高效地识别最长公共前缀。

3. **迭代算法**: FIRST集和FOLLOW集的计算采用迭代算法，确保结果收敛。

4. **命令行接口**: 提供了友好的命令行接口，支持多种操作模式和详细输出。

### 改进方向

1. **LL(1)分析器**: 可以进一步实现LL(1)文法判定和预测分析器（任务3.4）。

2. **图形化界面**: 可以开发图形用户界面（GUI），提供更直观的可视化效果。

3. **更多测试用例**: 可以增加更多测试文法，覆盖各种边界情况。

4. **性能优化**: 对于大规模文法，可以优化算法性能。

### 实验体会

通过本次实验，我深刻理解了语法分析在编译过程中的重要性。消除左递归和提取左公因子是构造LL(1)文法的关键步骤，而FIRST集和FOLLOW集是构建预测分析表的基础。这些算法的实现不仅加深了我对编译原理理论的理解，也提高了我的编程能力和算法设计能力。

---

**实验完成！**