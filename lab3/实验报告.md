# 杭州电子科技大学
# 《编译原理课程实践》
# 实验报告

---

|      |      |
|------|------|
| **题 目** | 语法分析算法实现（任务3.1-3.4） |
| **学 院** |  |
| **专 业** |  |
| **班 级** |  |
| **学 号** |  |
| **姓 名** |  |
| **完成日期** |  |

---

## 一、实验目的

1. 熟悉上下文无关文法的表示方式与解析流程。
2. 掌握消除左递归、提取左公因子、FIRST/FOLLOW 集计算方法。
3. 构造 LL(1) 预测分析表并完成 LL(1) 判定。
4. 通过命令行与可视化界面展示算法过程与结果。

## 二、实验内容与实验要求

1. 按四段式格式解析文法文件（注释以 `#` 开头，空串用 `@` 表示）。
2. 实现任务3.1：消除直接与间接左递归。
3. 实现任务3.2：提取左公因子，必要时递归提取更长公共前缀。
4. 实现任务3.3：FIRST/FOLLOW 集迭代计算并输出。
5. 实现任务3.4：构造 LL(1) 预测分析表，记录冲突并判定是否 LL(1)。
6. 支持命令行入口 `lab3/main.py` 与可视化入口 `lab3/app.py`，覆盖 `lab3/test_grammars/` 的测试用例。

## 三、设计方案与算法描述

### 1. 总体结构

- `lab3/src/grammar.py`：文法符号、产生式、文法结构。
- `lab3/src/parser.py`：文法解析器，支持多字符终结符与 `@` 空串。
- `lab3/src/left_recursion.py`：左递归消除。
- `lab3/src/left_factoring.py`：左公因子提取。
- `lab3/src/first_follow.py`：FIRST/FOLLOW 集计算。
- `lab3/src/ll1_parser.py`：LL(1) 表构造与判定。
- `lab3/main.py`：命令行驱动。
- `lab3/app.py`：Streamlit 可视化界面。

### 2. 关键数据结构

- `Symbol`：符号值与类型（终结符/非终结符/空串）。
- `Production`：产生式 `left -> right`。
- `Grammar`：非终结符/终结符集合、产生式列表、开始符号及符号表。

### 3. 主要算法流程

#### 3.1 消除左递归

1. 对非终结符按字典序排序。
2. 若产生式右部首符号是先序非终结符，进行代换以消除间接左递归。
3. 对直接左递归 `A -> Aα | β`，引入 `A'`，重写为 `A -> βA'`，`A' -> αA' | @`。

#### 3.2 提取左公因子

1. 以产生式右部首符号分组。
2. 若某组包含多条产生式，提取该首符号并生成新非终结符。
3. 对新非终结符递归处理，逐步形成更长公共前缀。

#### 3.3 FIRST/FOLLOW 集计算

1. FIRST：终结符与空串初始化，非终结符迭代更新至收敛。
2. FOLLOW：开始符号含 `$`，按规则迭代更新至收敛。

#### 3.4 LL(1) 预测分析表

1. 对产生式 `A -> α` 计算 `FIRST(α)`，填入 `M[A, a]`。
2. 若 `@ ∈ FIRST(α)`，将 `FOLLOW(A)` 中终结符加入表项。
3. 表项冲突则判定非 LL(1)。

## 四、测试结果

### 1. 测试环境

- Python >= 3.11
- 依赖：`streamlit`
- 测试脚本：`lab3/run_tests.py`

### 2. 用例一：表达式文法（消除左递归 + FIRST/FOLLOW + LL(1)）

输入文法（`lab3/test_grammars/expr_grammar_raw.txt`）:
```
E -> E + T | T
T -> T * F | F
F -> ( E ) | id
```

消除左递归后:
```
E -> T E'
E' -> + T E' | @
T -> F T'
T' -> * F T' | @
F -> ( E ) | id
```

FIRST/FOLLOW:
```
FIRST(E)  = {(, id}
FIRST(E') = {+, @}
FIRST(T)  = {(, id}
FIRST(T') = {*, @}
FIRST(F)  = {(, id}

FOLLOW(E)  = {$, )}
FOLLOW(E') = {$, )}
FOLLOW(T)  = {$, ), +}
FOLLOW(T') = {$, ), +}
FOLLOW(F)  = {$, ), *, +}
```

LL(1) 判定：无冲突，判定为 LL(1)。

### 3. 用例二：左公因子提取（节选）

输入产生式（节选自 `lab3/test_grammars/complex_grammar.txt`）:
```
A -> a b c | a b d
```

提取左公因子后:
```
A -> a A'
A' -> b A''
A'' -> c | d
```

## 五、源代码

以下为核心实现片段（完整代码见 `lab3/src/`、`lab3/main.py` 与 `lab3/app.py`）。

### 1. 文法结构（`lab3/src/grammar.py`）

```python
class SymbolType(Enum):
    """文法符号类型枚举"""

    TERMINAL = "terminal"  # 终结符
    NON_TERMINAL = "non_terminal"  # 非终结符
    EPSILON = "epsilon"  # 空串


@dataclass
class Symbol:
    """
    文法符号类，表示终结符、非终结符或空串。

    属性:
        value: 符号的值（如 'E', '+', 'id'）
        symbol_type: 符号的类型（终结符、非终结符或空串）
    """

    value: str
    symbol_type: SymbolType

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash((self.value, self.symbol_type))

    def __eq__(self, other) -> bool:
        if not isinstance(other, Symbol):
            return False
        return self.value == other.value and self.symbol_type == other.symbol_type


# 预定义空串符号
EPSILON = Symbol("@", SymbolType.EPSILON)


@dataclass
class Production:
    """
    产生式类，表示文法的一条规则。

    属性:
        left: 产生式左部（非终结符）
        right: 产生式右部（符号列表）

    示例:
        E -> T E'  表示为 Production(left=E, right=[T, E'])
    """

    left: Symbol
    right: List[Symbol]

    def __str__(self) -> str:
        right_str = " ".join(str(sym) for sym in self.right) if self.right else str(EPSILON)
        return f"{self.left} -> {right_str}"


@dataclass
class Grammar:
    """
    上下文无关文法类，包含文法的所有组成部分。

    属性:
        non_terminals: 非终结符集合（Symbol集合）
        terminals: 终结符集合（Symbol集合）
        productions: 产生式列表
        start_symbol: 开始符号（非终结符）
        symbol_map: 符号映射，用于快速查找符号（值 -> Symbol对象）

    注意:
        - 所有符号（包括终结符和非终结符）都存储在 symbol_map 中，便于快速查找和去重
        - 空串 '@' 被视为特殊的终结符
    """

    non_terminals: Set[Symbol] = field(default_factory=set)
    terminals: Set[Symbol] = field(default_factory=set)
    productions: List[Production] = field(default_factory=list)
    start_symbol: Optional[Symbol] = None
    symbol_map: Dict[str, Symbol] = field(default_factory=dict)

    def add_symbol(self, value: str, symbol_type: SymbolType) -> Symbol:
        """
        添加一个符号到文法中。

        如果符号已存在，则返回已存在的符号对象；
        否则创建新符号并添加到相应的集合中。
        """
        if value in self.symbol_map:
            return self.symbol_map[value]

        symbol = Symbol(value, symbol_type)
        self.symbol_map[value] = symbol

        if symbol_type == SymbolType.NON_TERMINAL:
            self.non_terminals.add(symbol)
        elif symbol_type == SymbolType.TERMINAL:
            self.terminals.add(symbol)

        return symbol

    def add_production(self, left: Symbol, right: List[Symbol]) -> None:
        """添加一个产生式到文法中。"""
        if left.symbol_type != SymbolType.NON_TERMINAL:
            raise ValueError(f"产生式左部必须是终结符: {left}")

        production = Production(left, right)
        self.productions.append(production)

    def get_productions_for(self, non_terminal: Symbol) -> List[Production]:
        """获取指定非终结符的所有产生式。"""
        return [p for p in self.productions if p.left == non_terminal]
```

### 2. 文法解析（`lab3/src/parser.py`）

```python
@staticmethod
def parse_string(content: str) -> Grammar:
    """
    从字符串解析文法。
    """
    lines = []
    for line in content.split("\n"):
        comment_pos = line.find("#")
        if comment_pos != -1:
            line = line[:comment_pos]
        line = line.strip()
        if line:
            lines.append(line)

    if len(lines) < 4:
        raise ValueError("文法文件格式错误：至少需要4行（非终结符、终结符、开始符号、至少一个产生式）")

    grammar = Grammar()

    non_terminal_values = [nt.strip() for nt in lines[0].split(",")]
    for nt_val in non_terminal_values:
        if nt_val:
            grammar.add_symbol(nt_val, SymbolType.NON_TERMINAL)

    terminal_values = [t.strip() for t in lines[1].split(",")]
    for t_val in terminal_values:
        if t_val:
            grammar.add_symbol(t_val, SymbolType.TERMINAL)

    start_value = lines[2].strip()
    if start_value not in grammar.symbol_map:
        raise ValueError(f"开始符号 '{start_value}' 未在非终结符中定义")
    start_symbol = grammar.symbol_map[start_value]
    if start_symbol.symbol_type != SymbolType.NON_TERMINAL:
        raise ValueError(f"开始符号 '{start_value}' 必须是非终结符")
    grammar.start_symbol = start_symbol

    for line in lines[3:]:
        GrammarParser._parse_production_line(line, grammar)

    GrammarParser._validate_grammar(grammar)

    return grammar


@staticmethod
def _parse_production_line(line: str, grammar: Grammar) -> None:
    """
    解析一行产生式。
    """
    if "->" not in line:
        raise ValueError(f"产生式格式错误（缺少 '->'）: {line}")

    left_part, right_part = line.split("->", 1)
    left_part = left_part.strip()
    right_part = right_part.strip()

    if left_part not in grammar.symbol_map:
        raise ValueError(f"产生式左部 '{left_part}' 未定义")
    left_symbol = grammar.symbol_map[left_part]
    if left_symbol.symbol_type != SymbolType.NON_TERMINAL:
        raise ValueError(f"产生式左部 '{left_part}' 必须是非终结符")

    candidates = [c.strip() for c in right_part.split("|")]

    for candidate in candidates:
        if not candidate:
            continue

        if candidate == "@":
            grammar.add_production(left_symbol, [EPSILON])
            continue

        symbols = []
        tokens = re.findall(r"\S+", candidate)

        for token in tokens:
            if token in grammar.symbol_map:
                symbols.append(grammar.symbol_map[token])
            else:
                symbol = grammar.add_symbol(token, SymbolType.TERMINAL)
                symbols.append(symbol)

        grammar.add_production(left_symbol, symbols)
```

### 3. 消除左递归（`lab3/src/left_recursion.py`）

```python
def _eliminate_direct_left_recursion(self, sorted_non_terminals: List[Symbol]) -> None:
    """
    消除直接左递归。

    对每个Ai:
    - 非左递归产生式 Ai -> β 转换为 Ai -> βAi'
    - 左递归产生式 Ai -> Aiα 转换为 Ai' -> αAi'
    - 添加 Ai' -> ε
    - 若 Ai 仅有左递归产生式，额外添加 Ai -> Ai'
    """
    self.processing_log.append("\n" + "-" * 50)
    self.processing_log.append("步骤4: 消除直接左递归")
    self.processing_log.append("-" * 50)

    for ai in sorted_non_terminals:
        ai_productions = self.result_grammar.get_productions_for(ai)

        left_recursive_prods = [p for p in ai_productions if p.right and p.right[0] == ai]
        non_left_recursive_prods = [p for p in ai_productions if not (p.right and p.right[0] == ai)]

        if not left_recursive_prods:
            continue

        self.processing_log.append(f"\n处理非终结符 {ai}:")
        self.processing_log.append(f"  发现 {len(left_recursive_prods)} 个左递归产生式")

        new_nt_name = f"{ai.value}'"
        while new_nt_name in self.result_grammar.symbol_map:
            new_nt_name += "'"
        new_nt = self.result_grammar.add_symbol(new_nt_name, SymbolType.NON_TERMINAL)
        self.processing_log.append(f"  创建新非终结符: {new_nt}")

        for prod in ai_productions:
            self.result_grammar.productions.remove(prod)

        if non_left_recursive_prods:
            for prod in non_left_recursive_prods:
                beta = prod.right
                if not beta or (len(beta) == 1 and beta[0] == EPSILON):
                    new_right = [new_nt]
                else:
                    new_right = beta + [new_nt]
                self.result_grammar.add_production(ai, new_right)
                self.processing_log.append(f"  转换: {prod} -> {ai} -> {' '.join(str(s) for s in new_right)}")
        else:
            self.result_grammar.add_production(ai, [new_nt])
            self.processing_log.append(f"  添加: {ai} -> {new_nt}")

        for prod in left_recursive_prods:
            alpha = prod.right[1:]
            if len(alpha) == 1 and alpha[0] == EPSILON:
                alpha = []
            new_right = alpha + [new_nt]
            self.result_grammar.add_production(new_nt, new_right)
            self.processing_log.append(f"  添加: {new_nt} -> {' '.join(str(s) for s in new_right)}")

        self.result_grammar.add_production(new_nt, [EPSILON])
        self.processing_log.append(f"  添加: {new_nt} -> {EPSILON}")
```

### 4. 提取左公因子（`lab3/src/left_factoring.py`）

```python
def _process_non_terminal(self, non_terminal: Symbol) -> List[Symbol]:
    """
    对单个非终结符进行左公因子提取。

    返回新创建的非终结符列表，供后续递归处理。
    """
    productions = self.result_grammar.get_productions_for(non_terminal)
    if len(productions) < 2:
        return []

    self.processing_log.append(f"\n处理非终结符 {non_terminal}:")
    self.processing_log.append("  原始产生式:")
    for prod in productions:
        self.processing_log.append(f"    {prod}")

    groups = self._group_by_first_symbol(productions)
    factoring_groups = {k: v for k, v in groups.items() if k is not None and len(v) > 1}

    if not factoring_groups:
        self.processing_log.append("  未发现可提取的左公因子")
        return []

    new_non_terminals: List[Symbol] = []
    productions_to_remove: List[Production] = []
    productions_to_add: List[tuple[Symbol, List[Symbol]]] = []

    for first_symbol, group in factoring_groups.items():
        new_nt = self._create_new_non_terminal(non_terminal)
        new_non_terminals.append(new_nt)
        productions_to_remove.extend(group)

        new_right = [first_symbol, new_nt]
        productions_to_add.append((non_terminal, new_right))
        self.processing_log.append(f"  发现左公因子: {first_symbol}")
        self.processing_log.append(f"  创建新非终结符: {new_nt}")
        self.processing_log.append(f"  替换为: {non_terminal} -> {' '.join(str(s) for s in new_right)}")

        for prod in group:
            remainder = prod.right[1:]
            if not remainder or remainder == [EPSILON]:
                remainder = [EPSILON]
            productions_to_add.append((new_nt, remainder))
            self.processing_log.append(
                f"    {non_terminal} 的产生式 {prod} 贡献: {new_nt} -> {' '.join(str(s) for s in remainder)}"
            )

    for prod in productions_to_remove:
        if prod in self.result_grammar.productions:
            self.result_grammar.productions.remove(prod)

    for left, right in productions_to_add:
        self.result_grammar.add_production(left, right)

    return new_non_terminals


@staticmethod
def _group_by_first_symbol(
    productions: List[Production],
) -> Dict[Optional[Symbol], List[Production]]:
    """按右部首符号分组产生式，空产生式归为 None 组。"""
    groups: Dict[Optional[Symbol], List[Production]] = {}
    for prod in productions:
        if not prod.right or prod.right == [EPSILON]:
            key = None
        else:
            key = prod.right[0]
        groups.setdefault(key, []).append(prod)
    return groups


def _create_new_non_terminal(self, base: Symbol) -> Symbol:
    """基于原非终结符生成唯一的新非终结符。"""
    new_name = f"{base.value}'"
    while new_name in self.result_grammar.symbol_map:
        new_name += "'"
    return self.result_grammar.add_symbol(new_name, SymbolType.NON_TERMINAL)
```

### 5. FIRST/FOLLOW 集（`lab3/src/first_follow.py`）

```python
def _add_first_from_production(self, production) -> None:
    """
    从产生式添加FIRST集元素。

    对于产生式 A -> X1 X2 ... Xk:
    - 将FIRST(X1)中的所有非ε元素加入FIRST(A)
    - 如果ε ∈ FIRST(X1)，则将FIRST(X2)中的所有非ε元素加入FIRST(A)
    - 如果ε ∈ FIRST(X1), FIRST(X2), ..., FIRST(Xk)，则将ε加入FIRST(A)
    """
    left_nt = production.left
    right_symbols = production.right

    if not right_symbols or right_symbols == [EPSILON]:
        self.first_sets[left_nt].add(EPSILON)
        return

    for i, symbol in enumerate(right_symbols):
        if symbol in self.first_sets:
            symbol_first = self.first_sets[symbol]
            self.first_sets[left_nt].update(symbol_first - {EPSILON})

        if symbol not in self.first_sets or EPSILON not in self.first_sets[symbol]:
            break

        if i == len(right_symbols) - 1:
            self.first_sets[left_nt].add(EPSILON)


def _iterate_follow_sets(self) -> None:
    """迭代计算FOLLOW集"""
    self.follow_log.append("\n步骤2: 迭代计算FOLLOW集")
    self.follow_log.append("-" * 40)

    iteration = 0
    changed = True

    while changed:
        changed = False
        iteration += 1

        self.follow_log.append(f"\n  第 {iteration} 次迭代:")

        for production in self.grammar.productions:
            right_symbols = production.right

            for i, symbol in enumerate(right_symbols):
                if symbol.symbol_type != SymbolType.NON_TERMINAL:
                    continue

                old_size = len(self.follow_sets[symbol])

                if i + 1 < len(right_symbols):
                    beta = right_symbols[i + 1 :]
                    first_of_beta = self._compute_first_of_string(beta)
                    self.follow_sets[symbol].update(first_of_beta - {EPSILON})

                    if EPSILON in first_of_beta:
                        self.follow_sets[symbol].update(self.follow_sets[production.left])
                else:
                    self.follow_sets[symbol].update(self.follow_sets[production.left])

                new_size = len(self.follow_sets[symbol])
                if new_size > old_size:
                    changed = True
                    self.follow_log.append(
                        f"    FOLLOW({symbol}) = {{{self._set_to_str(self.follow_sets[symbol])}}}"
                    )

    self.follow_log.append(f"\n  共迭代 {iteration} 次，FOLLOW集不再变化")
```

### 6. LL(1) 预测分析表（`lab3/src/ll1_parser.py`）

```python
def build_table(self) -> TableType:
    """构造预测分析表，并记录冲突信息。"""
    self.table = {}
    self.conflicts = []
    self.is_ll1 = True

    for production in self.grammar.productions:
        first_alpha = self._first_of_string(production.right)

        for terminal in (sym for sym in first_alpha if sym != EPSILON):
            self._add_entry(production.left, terminal.value, production)

        if EPSILON in first_alpha:
            for follow_sym in self.follow_sets.get(production.left, set()):
                if follow_sym.symbol_type != SymbolType.TERMINAL:
                    continue
                self._add_entry(production.left, follow_sym.value, production)

    return self.table


def _add_entry(self, non_terminal: Symbol, terminal_value: str, production: Production) -> None:
    """在表中添加一项，若发生冲突则记录并标记为非 LL(1)。"""
    row = self.table.setdefault(non_terminal, {})
    if terminal_value in row and row[terminal_value] != production:
        self.is_ll1 = False
        conflict_msg = (
            f"冲突: M[{non_terminal}, {terminal_value}] 已有 {row[terminal_value]}, "
            f"再次填入 {production}"
        )
        self.conflicts.append(conflict_msg)
    else:
        row[terminal_value] = production


def _first_of_string(self, symbols: List[Symbol]) -> Set[Symbol]:
    """计算符号串的 FIRST 集（使用已知 FIRST 集）。"""
    if not symbols:
        return {EPSILON}

    result: Set[Symbol] = set()

    for i, symbol in enumerate(symbols):
        if symbol == EPSILON:
            result.add(EPSILON)
            break

        symbol_first = self.first_sets.get(symbol, {symbol})
        result.update(symbol_first - {EPSILON})

        if EPSILON not in symbol_first:
            break

        if i == len(symbols) - 1:
            result.add(EPSILON)

    return result
```
