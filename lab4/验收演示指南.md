# SysY 编译器前端 - 验收演示指南

## 一、项目概述

本项目实现了 SysY 语言（C 语言子集）的编译器前端，包含三个核心阶段：

```
源代码 (.sy) → 词法分析 → 语法分析 → 语义分析 → 成功/错误报告
```

### 1.1 目录结构

```
lab4/
├── main.py                 # 程序入口
├── src/
│   ├── token_type.py       # Token 类型定义
│   ├── lexer.py            # 词法分析器
│   ├── ast_nodes.py        # AST 节点定义
│   ├── parser.py           # 语法分析器（递归下降）
│   ├── symbol_table.py     # 符号表与作用域
│   └── semantic_analyzer.py # 语义分析器
└── test_cases/             # 测试用例
    ├── test_01_basic.sy    # 基础测试
    ├── test_09_lex_error.sy    # 词法错误测试
    ├── test_10_syntax_error.sy # 语法错误测试
    └── test_11_semantic_error.sy # 语义错误测试
```

---

## 二、运行环境准备

```bash
cd lab4
# 确保使用 uv 管理的 Python 环境
uv sync  # 安装依赖（如果需要）
```

---

## 三、验收演示步骤

### 3.1 词法分析演示（任务 4.2）

**原理**：将源代码字符流分割成 Token 序列，识别关键字、标识符、数字常量、运算符等。

**演示命令**：
```bash
uv run python main.py --lexer test_cases/test_01_basic.sy
```

**预期输出**：
```
INTTK int
IDENFR main
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR student_id
ASSIGN =
INTCON 20220001
SEMICN ;
...
```

**数值转换特性演示**（八进制/十六进制→十进制）：
```bash
uv run python main.py --lexer test_cases/test_octal.sy
```

**词法错误检测演示**（Error type A）：
```bash
uv run python main.py --lexer test_cases/test_09_lex_error.sy
```

**预期输出**：
```
Error type A at Line X: Invalid character '@'
Error type A at Line X: Unterminated block comment
```

---

### 3.2 语法分析演示（任务 4.3）

**原理**：使用递归下降解析器，根据 SysY 文法规则构建抽象语法树（AST）。

**核心文法**（简化）：
```
CompUnit → { Decl | FuncDef }
FuncDef → FuncType Ident '(' [FuncFParams] ')' Block
Block → '{' { BlockItem } '}'
Stmt → LVal '=' Exp ';' | 'if' '(' Cond ')' Stmt | ...
```

**演示命令**：
```bash
uv run python main.py --parser test_cases/test_01_basic.sy
```

**预期输出**（AST 先序遍历）：
```
CompUnit (4)
  FuncDef (4)
    FuncType (4)
      Type: int
    Ident: main
    LPARENT
    RPARENT
    Block (4)
      LBRACE
      BlockItem (5)
        Decl (5)
          VarDecl (5)
            ...
```

**控制流解析演示**：
```bash
uv run python main.py --parser test_cases/test_03_control.sy
```

**语法错误检测演示**（Error type B）：
```bash
uv run python main.py --parser test_cases/test_10_syntax_error.sy
```

**预期输出**：
```
Error type B at Line 7: Missing ']'
Error type B at Line 10: Missing ';'
```

---

### 3.3 语义分析演示（任务 4.4）

**原理**：遍历 AST，建立符号表，检查语义规则。

**符号表机制**：
- 作用域栈：全局作用域 → 函数作用域 → 块作用域
- 符号查找：从内向外逐层查找
- 内置函数：预定义 `getint`, `putint`, `getch`, `putch` 等 12 个库函数

**演示命令**：
```bash
uv run python main.py --semantic test_cases/test_11_semantic_error.sy
```

**预期输出**（检测所有 5 种语义错误）：
```
Error type 1 at Line 8: Undefined variable 'undefined_var'
Error type 2 at Line 12: Redefined variable 'b'
Error type 3 at Line 15: Undefined function 'undefined_func'
Error type 9 at Line 18: Function 'getint' expects 0 arguments but got 1
Error type 9 at Line 19: Function 'putint' expects 1 arguments but got 0
Error type 10 at Line 26: Return value in void function 'test_void'
Error type 10 at Line 30: Missing return value in non-void function 'test_int'
```

**正确代码验证**：
```bash
uv run python main.py --semantic test_cases/test_01_basic.sy
```

**预期输出**：
```
success
```

---

## 四、错误类型总结

| 错误类型 | 阶段 | 描述 | 示例 |
|---------|------|------|------|
| Error type A | 词法 | 非法字符、未闭合注释 | `@`, `/* 未闭合` |
| Error type B | 语法 | 缺少符号、语法结构错误 | 缺少 `;`, `]`, `}` |
| Error type 1 | 语义 | 使用未定义的变量 | `int a = b;` (b 未定义) |
| Error type 2 | 语义 | 变量/函数重复定义 | 同一作用域内两次 `int x;` |
| Error type 3 | 语义 | 调用未定义的函数 | `foo();` (foo 未定义) |
| Error type 9 | 语义 | 函数参数不匹配 | `getint(1)` 或 `putint()` |
| Error type 10 | 语义 | return 类型不匹配 | void 函数返回值 |

---

## 五、关键技术点解释

### 5.1 词法分析器 (lexer.py)

**核心方法**：
- `scan_number()`: 识别整数/浮点数，支持八进制(0123)、十六进制(0xFF)
- `scan_identifier()`: 识别标识符和关键字
- `skip_comment()`: 跳过单行//和多行/**/注释

**特色功能**：数值常量自动转换为十进制输出

### 5.2 语法分析器 (parser.py)

**核心方法**：
- `parse_comp_unit()`: 解析编译单元
- `parse_func_def()`: 解析函数定义
- `parse_stmt()`: 解析语句（赋值、if、while、return 等）
- `parse_exp()` → `parse_add_exp()` → `parse_mul_exp()` → `parse_unary_exp()`: 表达式解析链

**错误恢复**：`synchronize()` 方法在遇到错误时跳到下一个语句边界

### 5.3 语义分析器 (semantic_analyzer.py)

**核心数据结构**：
- `Symbol`: 符号表条目（名称、类型、作用域层级）
- `Scope`: 作用域（符号字典 + 父作用域引用）
- `SymbolTable`: 符号表管理器（作用域栈）

**核心方法**：
- `visit_var_def()`: 检查变量重复定义（Error type 2）
- `visit_lval()`: 检查变量是否已定义（Error type 1）
- `visit_unary_exp()`: 检查函数调用（Error type 3, 9）
- `visit_stmt()`: 检查 return 类型（Error type 10）

---

## 六、完整测试流程

```bash
# 1. 词法分析测试
uv run python main.py --lexer test_cases/test_01_basic.sy
uv run python main.py --lexer test_cases/test_09_lex_error.sy

# 2. 语法分析测试
uv run python main.py --parser test_cases/test_01_basic.sy
uv run python main.py --parser test_cases/test_04_func.sy
uv run python main.py --parser test_cases/test_10_syntax_error.sy

# 3. 语义分析测试
uv run python main.py --semantic test_cases/test_01_basic.sy
uv run python main.py --semantic test_cases/test_04_func.sy
uv run python main.py --semantic test_cases/test_11_semantic_error.sy
```

---

## 七、常见问题解答

**Q: 为什么数字 0123 输出为 83？**
A: 因为以 0 开头的数字被识别为八进制，0123(八进制) = 1×64 + 2×8 + 3 = 83(十进制)

**Q: 为什么 test_scope 函数中嵌套的 `int x` 不报重复定义错误？**
A: 因为它们在不同的作用域中。内层 `{...}` 创建了新作用域，允许隐藏外层变量。

**Q: 如何查看 AST 结构？**
A: 使用 `--parser` 参数，输出的是 AST 的先序遍历结果，缩进表示层级关系。

---

## 八、项目亮点

1. **完整的编译器前端**：词法→语法→语义三阶段完整实现
2. **递归下降解析器**：手写解析器，便于理解和调试
3. **作用域栈**：正确处理嵌套作用域的变量查找
4. **内置函数**：预定义 SysY 标准库函数
5. **错误恢复**：语法错误后能继续解析，报告多个错误
6. **详细的错误信息**：包含行号和具体错误描述